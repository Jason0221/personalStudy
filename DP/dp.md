### 动态规划的特点

1. 计数
    * 有多少方式走到右下角
    * 有多少种方法选出k个数, 使得和是sum
2. 求最大值最小值
    * 从左上角走到右下角路径的最大数字和
    * 最长上升子序列长度
3. 求存在性
    * 取石子游戏, 先手是够必胜
    * 能不能取出k个数,使得和是sum

#### 例题1
有三种硬币, 2,5,7 面值, 每种都足够多, 一本书27元. 如何使用最少的硬币组合,正好是书的价值

分析: 
思考1: 
要最少的硬币组合 ---> 尽量用面值大的硬币
7 + 7 + 7 = 21
21 + 5 = 26  不符合了.....
换一个思路: 
尽量用最大的硬币,最后如果可以, 使用一种硬币付清就好: 
7 + 7 + 7 = 21
21 + 2 + 2 + 2 = 27
一共6枚
是否最优???

其实不能这么玩儿,  这种思路没法证明其正确性..... 


要使用4个正确步骤

1 步骤1: 确定状态

简要的说, 解动态规划的时候, 需要开一个数组, 数组的每个元素f[i]或者f[i][j]代表什么
* 类似于数学中的 xyz 代表什么
确定状态需要两个意识: 
    * 最后一步
    * 子问题
例题中怎样确定最后一步: 

最优策略肯定是K枚硬币,a1,a2..... ak, 面值加起来为27, 所以最后一枚硬币就是 ak
除掉这枚硬币, 前面的面值加起来应该是 27 - ak 
* 关键点1: 
    不用关心前面的 27-ak是怎么拼出来的, 反正他的值是ak,前面的硬币拼出了 27 - ak
* 关键点2: 
    因为是最优策略, 所以拼出 27 - ak 的面额 的硬币数, 也一定是最少的. 

这时候, 子问题就出来了:   用最少的硬币数, 拼出  27 - ak

为了简化定义, 我们 设状态 f(X) = 最少用多少枚硬币拼出X
我们可以得出另一个表达式: 

f(27) = f(27 - ak) + 1

目前, 我们还不知道 ak 是多少,  不过, 他只能是 2, 5, 7 之中的一个

so: 
* ak 是 2, f(27) =  f(27 -2) + 1
* ak 是 5, f(27) =  f(27 -5) + 1
* ak 是 7, f(27) =  f(27 -7) + 1
 
需求是求最少的硬币数,  so:


f(27) = min{ f(25) + 1, f(22) + 1, f(20) + 1 }

2. 转移方程: 

f[X] = min { f[X-2] + 1, f[X-5] + 1,  f[X-7] + 1}

3. 常初始条件和边界情况

f[X] = min{f[X-2] + 1, f[X-5] + 1, f[X-7] + 1}
两个问题: X-2, X-5, X-7 小于等于0 时怎么办? 什么时候停下来? 

首先定义:  如果拼不出Y, 则定义f[Y] = 正无穷,  例如 f[1] = f[-1] =  正无穷
这里的初始: f[0] = 0

初始条件:  用转移方程算不出来的, 但是又需要的值.

4. 计算顺序: 

初始条件: f[0] = 0
然后计算 f[1], f[2].... f[27]

原则: 当计算到f[X]时, f[X-2], f[X-5], f[X-7]的值已经知道了
